#%%writefile static/index.html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Audio Mixer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 32px;
            max-width: 600px;
            width: 100%;
        }
        h1 {
            color: #333;
            margin-bottom: 24px;
            text-align: center;
            font-size: 28px;
        }
        .track {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            border: 2px solid #e9ecef;
        }
        .track h3 {
            color: #495057;
            margin-bottom: 12px;
            font-size: 16px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: #6c757d;
            font-size: 14px;
            font-weight: 500;
        }
        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 12px;
            transition: border-color 0.2s;
        }
        input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        .volume-value {
            min-width: 45px;
            text-align: right;
            font-weight: 600;
            color: #495057;
        }
        .controls {
            display: flex;
            gap: 8px;
            margin-top: 24px;
        }
        button {
            flex: 1;
            min-width: 0;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        #btn-start {
            background: #667eea;
            color: white;
        }
        #btn-start:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        #btn-stop {
            background: #dc3545;
            color: white;
        }
        #btn-stop:hover:not(:disabled) {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status {
            margin-top: 16px;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .status.idle { background: #e9ecef; color: #6c757d; }
        .status.loading { background: #fff3cd; color: #856404; }
        .status.recording { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.success { background: #d1ecf1; color: #0c5460; }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(0,0,0,0.1);
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        @keyframes pulse-red {
            0% { background-color: #dc3545; box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            50% { background-color: #ff4d5a; box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { background-color: #dc3545; box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }
        .recording-active {
            animation: pulse-red 2s infinite;
            color: white !important;
            border: none !important;
        }
        .timer {
            text-align: center;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 24px;
            font-weight: bold;
            color: #dc3545;
            background-color: #fff0f0;
            padding: 8px 5px;
            border-radius: 8px;
            border: 2px solid #ffc9c9;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            min-height: 45px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .timer.recording-bg {
            background-image: linear-gradient(
                45deg,
                rgba(255, 200, 200, 0.4) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255, 200, 200, 0.4) 50%,
                rgba(255, 200, 200, 0.4) 75%,
                transparent 75%,
                transparent
            );
            background-size: 40px 40px;
            animation: move-stripe 2s linear infinite;
        }
        @keyframes move-stripe {
            from { background-position: 0 0; }
            to { background-position: 40px 0; }
        }
        .tab-group {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .tab-btn {
            flex: 1;
            padding: 12px 5px;
            font-size: 14px;
            background: #e9ecef;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
        }
        .tab-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        .track-view {
            min-height: 250px;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
        }
        .playing-stripe {
            background: linear-gradient(
                45deg,
                rgba(209, 236, 241, 1) 25%,
                rgba(180, 225, 235, 1) 25%,
                rgba(180, 225, 235, 1) 50%,
                rgba(209, 236, 241, 1) 50%,
                rgba(209, 236, 241, 1) 75%,
                rgba(180, 225, 235, 1) 75%,
                rgba(180, 225, 235, 1) 100%
            ) ;
            background-size: 40px 40px !important;
            animation: move-stripe2 2s linear infinite !important;
            border: 1px solid #bee5eb !important;
        }
        @keyframes move-stripe2 {
            from { background-position: 0 0; }
            to { background-position: 80px 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ YouTube Audio Mixer</h1>

        <div class="track" id="track1">
            <div class="tab-group">
                <button type="button" class="tab-btn active" id="btn-tab-monitor1" onclick="switchView(1, 'monitor')">üì∫ Monitor</button>
                <button type="button" class="tab-btn" id="btn-tab-playlist1" onclick="switchView(1, 'playlist')">üìù Playlist</button>
                <button type="button" class="tab-btn" id="btn-tab-eq1" onclick="switchView(1, 'eq')">üéõÔ∏èÔ∏è EQ</button>
            </div>

            <div id="view-monitor1" class="track-view">
                <input type="hidden" id="url1" value="">
                <h3 style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    Track 1 <span id="time1" style="font-family: monospace; font-size: 18px; color: #666;">00:00:00</span>
                    <span id="seconds1" style="font-family: monospace; font-size: 14px; color: #718096; background: #edf2f7; padding: 2px 6px; border-radius: 4px;">[0s]</span>
                </h3>

                <div style="background: #e9ecef; padding: 8px 12px; border-radius: 6px; margin-bottom: 12px; text-align: center;">
                    <span style="font-size: 12px; color: #6c757d; font-weight: 500;">Repeat: </span>
                    <span id="repeatStatus1" style="font-size: 12px; font-weight: bold; color: #495057;">No Repeat</span>
                </div>

                <video id="v1" width="100%" height="auto" style="border-radius: 8px; background: #000; margin-bottom: 12px; display: block;" crossorigin="anonymous" playsinline muted></video>

                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button type="button" id="playPause1" onclick="toggleTrackPlay(1)" style="background: #007bff; color: white; flex:1;">Play</button>
                    <button type="button" onclick="resetTrack(1)" style="background: #6c757d; color: white; flex:1;">Reset</button>
                    <button type="button" id="mute1" onclick="toggleMute(1)" style="background: #6c757d; color: white; flex:1;">Mute</button>
                    <button type="button" onclick="hardResetTrack(1)" style="background: #dc3545; color: white; padding: 8px; font-size: 12px;" title="Hard Reset: Recreate video element">‚ò†Ô∏è</button>
                </div>

                <div style="margin-top:12px;">
                    <label>Start Time (Offset) - seconds</label>
                    <input type="number" id="start1" value="0" min="0" step="0.1" style="width:100%; margin-bottom: 12px;">
                </div>

                <div style="margin-top:12px;">
                    <label>Volume</label>
                    <div class="volume-control">
                        <input type="range" id="vol1" min="0" max="1" step="0.01" value="1">
                        <span class="volume-value" id="vol1-value">100%</span>
                    </div>
                </div>
            </div>

            <div id="view-playlist1" class="track-view" style="display: none;">
                <label>Add YouTube URL</label>
                <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                    <input type="text" id="urlInput1" placeholder="https://..." style="flex: 1; margin: 0;">
                    <button type="button" onclick="addToList(1)" style="background: #28a745; color: white; flex: 0 0 70px; border-radius:8px;">Add</button>
                </div>
                <ul id="playlist1" style="list-style: none; padding: 0; max-height: 180px; overflow-y: auto; background: #eee; border-radius: 8px; min-height: 50px; margin-bottom: 10px;"></ul>

                <div style="padding-top: 10px; border-top: 1px solid #eee;">
                    <label style="font-weight: bold; margin-bottom: 8px; display: block;">Repeat Mode:</label>
                    <label style="display:block; margin-bottom:5px; cursor: pointer;">
                        <input type="radio" name="repeatMode1" value="none" checked onchange="updateRepeatMode(1)"> No Repeat
                    </label>
                    <label style="display:block; margin-bottom:5px; cursor: pointer;">
                        <input type="radio" name="repeatMode1" value="item" onchange="updateRepeatMode(1)"> üîÇ Item Repeat (Loop current clip)
                    </label>
                    <label style="display:block; cursor: pointer;">
                        <input type="radio" name="repeatMode1" value="list" onchange="updateRepeatMode(1)"> üîÅ List Repeat (Loop entire playlist)
                    </label>
                </div>
            </div>

            <div id="view-eq1" class="track-view" style="display: none;">
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #dee2e6;">
                    <label style="display:flex; justify-content:space-between;">BASS <span id="eq-low-val1">0dB</span></label>
                    <input type="range" min="-15" max="15" value="0" style="width: 100%; margin-bottom: 15px;" oninput="updateEQ(1, 'low', this.value)">

                    <label style="display:flex; justify-content:space-between;">MID <span id="eq-mid-val1">0dB</span></label>
                    <input type="range" min="-15" max="15" value="0" style="width: 100%; margin-bottom: 15px;" oninput="updateEQ(1, 'mid', this.value)">

                    <label style="display:flex; justify-content:space-between;">TREBLE <span id="eq-high-val1">0dB</span></label>
                    <input type="range" min="-15" max="15" value="0" style="width: 100%;" oninput="updateEQ(1, 'high', this.value)">
                </div>
                <div class="fx-controls" style="margin-top: 10px; border-top: 1px dashed #ccc; padding-top: 10px;">
                    <div>
                        <small>Pitch: <span id="pitch-val1">0</span></small><br>
                        <input type="range" min="-12" max="12" value="0" step="0.5" style="width:100%"
                            oninput="updatePitch(1, this.value)">
                    </div>
                    <div style="margin-top: 5px;">
                        <small>Speed: <span id="speed-val1">1.00x</span></small><br>
                        <input type="range" min="0.5" max="2.0" value="1.0" step="0.01" style="width:100%"
                            oninput="updateSpeed(1, this.value)">
                    </div>
                </div>
            </div>
        </div>

        <div class="track" id="track2">
            <div class="tab-group">
                <button type="button" class="tab-btn active" id="btn-tab-monitor2" onclick="switchView(2, 'monitor')">üì∫ Monitor</button>
                <button type="button" class="tab-btn" id="btn-tab-playlist2" onclick="switchView(2, 'playlist')">üìù Playlist</button>
                <button type="button" class="tab-btn" id="btn-tab-eq2" onclick="switchView(2, 'eq')">üéõÔ∏è EQ</button>
            </div>

            <div id="view-monitor2" class="track-view">
                <input type="hidden" id="url2" value="">
                <h3 style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    Track 2 <span id="time2" style="font-family: monospace; font-size: 18px; color: #666;">00:00:00</span>
                    <span id="seconds2" style="font-family: monospace; font-size: 14px; color: #718096; background: #edf2f7; padding: 2px 6px; border-radius: 4px;">[0s]</span>                </h3>
                </h3>

                <div style="background: #e9ecef; padding: 8px 12px; border-radius: 6px; margin-bottom: 12px; text-align: center;">
                    <span style="font-size: 12px; color: #6c757d; font-weight: 500;">Repeat: </span>
                    <span id="repeatStatus2" style="font-size: 12px; font-weight: bold; color: #495057;">No Repeat</span>
                </div>

                <video id="v2" width="100%" height="auto" style="border-radius: 8px; background: #000; margin-bottom: 12px; display: block;" crossorigin="anonymous" playsinline muted></video>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button type="button" id="playPause2" onclick="toggleTrackPlay(2)" style="background: #007bff; color: white; flex:1;">Play</button>
                    <button type="button" onclick="resetTrack(2)" style="background: #6c757d; color: white; flex:1;">Reset</button>
                    <button type="button" id="mute2" onclick="toggleMute(2)" style="background: #6c757d; color: white; flex:1;">Mute</button>
                    <button type="button" onclick="hardResetTrack(2)" style="background: #dc3545; color: white; padding: 8px; font-size: 12px;" title="Hard Reset: Recreate video element">‚ò†Ô∏è</button>
                </div>

                <div style="margin-top:12px;">
                    <label>Start Time (Offset) - seconds</label>
                    <input type="number" id="start2" value="0" min="0" step="0.1" style="width:100%; margin-bottom: 12px;">
                </div>

                <div style="margin-top:12px;">
                    <label>Volume</label>
                    <div class="volume-control">
                        <input type="range" id="vol2" min="0" max="1" step="0.01" value="1">
                        <span class="volume-value" id="vol2-value">100%</span>
                    </div>
                </div>
            </div>

            <div id="view-playlist2" class="track-view" style="display: none;">
                <label>Add YouTube URL</label>
                <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                    <input type="text" id="urlInput2" placeholder="https://..." style="flex: 1; margin: 0;">
                    <button type="button" onclick="addToList(2)" style="background: #28a745; color: white; flex: 0 0 70px; border-radius:8px;">Add</button>
                </div>
                <ul id="playlist2" style="list-style: none; padding: 0; max-height: 180px; overflow-y: auto; background: #eee; border-radius: 8px; min-height: 50px; margin-bottom: 10px;"></ul>

                <div style="padding-top: 10px; border-top: 1px solid #eee;">
                    <label style="font-weight: bold; margin-bottom: 8px; display: block;">Repeat Mode:</label>
                    <label style="display:block; margin-bottom:5px; cursor: pointer;">
                        <input type="radio" name="repeatMode2" value="none" checked onchange="updateRepeatMode(2)"> No Repeat
                    </label>
                    <label style="display:block; margin-bottom:5px; cursor: pointer;">
                        <input type="radio" name="repeatMode2" value="item" onchange="updateRepeatMode(2)"> üîÇ Item Repeat (Loop current clip)
                    </label>
                    <label style="display:block; cursor: pointer;">
                        <input type="radio" name="repeatMode2" value="list" onchange="updateRepeatMode(2)"> üîÅ List Repeat (Loop entire playlist)
                    </label>
                </div>
            </div>

            <div id="view-eq2" class="track-view" style="display: none;">
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #dee2e6;">
                    <label style="display:flex; justify-content:space-between;">BASS <span id="eq-low-val2">0dB</span></label>
                    <input type="range" min="-15" max="15" value="0" style="width: 100%; margin-bottom: 15px;" oninput="updateEQ(2, 'low', this.value)">
                    <label style="display:flex; justify-content:space-between;">MID <span id="eq-mid-val2">0dB</span></label>
                    <input type="range" min="-15" max="15" value="0" style="width: 100%; margin-bottom: 15px;" oninput="updateEQ(2, 'mid', this.value)">
                    <label style="display:flex; justify-content:space-between;">TREBLE <span id="eq-high-val2">0dB</span></label>
                    <input type="range" min="-15" max="15" value="0" style="width: 100%;" oninput="updateEQ(2, 'high', this.value)">
                </div>
                <div class="fx-controls" style="margin-top: 10px; border-top: 1px dashed #ccc; padding-top: 10px;">
                    <div>
                        <small>Pitch: <span id="pitch-val2">0</span></small><br>
                        <input type="range" min="-12" max="12" value="0" step="1" style="width:100%"
                            oninput="updatePitch(2, this.value)">
                    </div>
                    <div style="margin-top: 5px;">
                        <small>Speed: <span id="speed-val2">1.00x</span></small><br>
                        <input type="range" min="0.5" max="2.0" value="1.0" step="0.01" style="width:100%"
                            oninput="updateSpeed(2, this.value)">
                    </div>
                </div>
            </div>
        </div>

        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd;">
            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                <div class="controls">
                    <button id="btn-start">Start Recording</button>
                    <button id="btn-rec-pause" disabled style="background: #fd7e14; color: #fff;">REC Pause</button>
                    <button id="btn-pause" disabled style="background: #ffc107; color: #000;">Pause</button>
                    <button id="btn-stop" disabled>Stop & Save</button>
                    <button id="btn-cancel" disabled>Cancel</button>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button type="button" onclick="playAllTracks()" style="background: #007bff; color: white;">‚ñ∂ Play All Tracks</button>
                </div>

                <div style="display: flex; align-items: center; gap: 10px;">
                    <label>Master Vol:</label>
                    <input type="range" id="masterVol" min="0" max="1.5" step="0.01" value="1.0" style="width: 350px;">
                    <span id="masterVol-value">100%</span>
                </div>

                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="downloadWebM" checked> Download WebM (for check)
                </label>
            </div>

            <button onclick="toggleMasterEQ()" id="btn-master-eq" style="margin-top: 10px; background: #6c757d; color: white; width: 100%;">üéöÔ∏è Master EQ</button>
        </div>

        <!-- LiveStream Panel -->
        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd;">
            <h3 style="margin-bottom: 10px; color: #495057; font-size: 16px;">üì° LiveStream to YouTube</h3>

            <div style="margin-bottom: 10px;">
                <label>RTMP URL (YouTube Stream Key)</label>
                <input type="text" id="rtmpUrl" placeholder="rtmp://a.rtmp.youtube.com/live2/xxxx-xxxx-xxxx-xxxx" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px; font-family: monospace;">
                <p style="font-size: 10px; color: #dc3545; margin: 3px 0 0 0;">‚ö†Ô∏è Must start with <code>rtmp://</code></p>
            </div>

            <div style="margin-bottom: 10px;">
                <label style="font-weight: bold; margin-bottom: 5px; display: block;">Video Source:</label>
                <label style="display: inline-block; margin-right: 15px; cursor: pointer;">
                    <input type="radio" name="videoSource" value="1" checked> Track 1
                </label>
                <label style="display: inline-block; cursor: pointer;">
                    <input type="radio" name="videoSource" value="2"> Track 2
                </label>
                <p style="font-size: 11px; color: #6c757d; margin: 5px 0 0 0;">Audio will always be from Master output (both tracks mixed)</p>
            </div>

            <!-- FFmpeg Parameters -->
            <details style="margin-top: 15px; padding: 10px; background: white; border-radius: 6px; border: 1px solid #ddd;">
                <summary style="cursor: pointer; font-weight: bold; color: #495057;">‚öôÔ∏è Advanced Settings (FFmpeg Parameters)</summary>

                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        Video Bitrate: <span id="videoBitrateValue" style="font-weight: bold; color: #007bff;">750k</span>
                    </label>
                    <input type="range" id="videoBitrate" min="500" max="9500" step="250" value="750"
                           oninput="document.getElementById('videoBitrateValue').textContent = this.value + 'k'"
                           style="width: 100%; margin-bottom: 10px;">
                    <p style="font-size: 10px; color: #6c757d; margin: 0 0 10px 0;">Recommended: 500-1500k for 360p-720p, up to 9500k for 1080p+</p>

                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        Audio Bitrate: <span id="audioBitrateValue" style="font-weight: bold; color: #007bff;">128k</span>
                    </label>
                    <input type="range" id="audioBitrate" min="64" max="320" step="32" value="128"
                           oninput="document.getElementById('audioBitrateValue').textContent = this.value + 'k'"
                           style="width: 100%; margin-bottom: 10px;">
                    <p style="font-size: 10px; color: #6c757d; margin: 0 0 10px 0;">Recommended: 128-192k for stereo</p>

                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        GOP Size (Keyframe Interval): <span id="gopSizeValue" style="font-weight: bold; color: #007bff;">60</span>
                    </label>
                    <input type="range" id="gopSize" min="30" max="120" step="30" value="60"
                           oninput="document.getElementById('gopSizeValue').textContent = this.value"
                           style="width: 100%; margin-bottom: 10px;">
                    <p style="font-size: 10px; color: #6c757d; margin: 0 0 10px 0;">Lower = more stable, Higher = better compression</p>

                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        Buffer Size: <span id="bufferSizeValue" style="font-weight: bold; color: #007bff;">4096</span>
                    </label>
                    <input type="range" id="bufferSize" min="512" max="16384" step="512" value="4096"
                           oninput="document.getElementById('bufferSizeValue').textContent = this.value"
                           style="width: 100%; margin-bottom: 10px;">
                    <p style="font-size: 10px; color: #6c757d; margin: 0 0 10px 0;">Larger = less audio drops, but more latency (max: 16384)</p>

                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        Audio Sync (-async): <span id="asyncValue" style="font-weight: bold; color: #007bff;">0</span>
                    </label>
                    <input type="range" id="asyncParam" min="0" max="10" step="1" value="0"
                           oninput="document.getElementById('asyncValue').textContent = this.value"
                           style="width: 100%; margin-bottom: 10px;">
                    <p style="font-size: 10px; color: #6c757d; margin: 0 0 10px 0;">0 = no sync (smooth audio, recommended), 1+ = force sync (may cause choppy audio)</p>

                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        Chunk Interval (ms): <span id="chunkIntervalValue" style="font-weight: bold; color: #007bff;">50</span>
                    </label>
                    <input type="range" id="chunkInterval" min="10" max="200" step="10" value="50"
                           oninput="document.getElementById('chunkIntervalValue').textContent = this.value"
                           style="width: 100%; margin-bottom: 10px;">
                    <p style="font-size: 10px; color: #6c757d; margin: 0 0 15px 0;">10-50ms = smooth but high load, 100-200ms = stable but chunky</p>

                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px; cursor: pointer;">
                        <input type="checkbox" id="denoiseEnabled" checked style="width: auto; margin: 0;">
                        <span style="font-weight: 500;">Enable Audio FFT DeNoise (afftdn)</span>
                    </label>
                    <p style="font-size: 10px; color: #6c757d; margin: 0 0 10px 0;">Reduces background noise using FFT-based filtering (recommended: ON)</p>

                    <button onclick="resetFFmpegDefaults()" style="margin-top: 10px; padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Reset to Defaults
                    </button>
                </div>
            </details>

            <div style="display: flex; gap: 8px; margin-top: 10px;">
                <button id="btn-livestream-start" onclick="startLiveStream()" style="flex: 1; background: #e74c3c; color: white; padding: 10px; border-radius: 8px; font-weight: bold;">üî¥ Start LiveStream</button>
                <button id="btn-livestream-stop" onclick="stopLiveStream()" disabled style="flex: 1; background: #95a5a6; color: white; padding: 10px; border-radius: 8px; font-weight: bold;">‚èπ Stop LiveStream</button>
            </div>

            <div id="livestream-status" style="margin-top: 10px; padding: 8px; border-radius: 4px; background: #ecf0f1; text-align: center; font-size: 12px; color: #7f8c8d;">
                Idle
            </div>
        </div>

        <!-- Master EQ Panel (12-Band) -->
        <div id="master-eq-panel" style="display: none; background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd;">
            <h3 style="text-align: center; margin-bottom: 15px;">Master EQ (12-Band)</h3>
            <div style="display: flex; justify-content: space-between; align-items: flex-end; gap: 4px; padding: 20px 10px; background: white; border-radius: 8px; overflow-x: auto;">
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-0" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(0, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">20Hz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-1" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(1, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">60Hz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-2" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(2, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">170Hz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-3" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(3, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">310Hz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-4" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(4, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">600Hz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-5" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(5, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">1kHz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-6" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(6, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">3kHz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-7" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(7, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">6kHz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-8" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(8, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">12kHz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-9" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(9, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">14kHz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-10" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(10, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">16kHz</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; min-width: 50px;">
                    <span id="meq-11" style="font-size: 10px; margin: 3px 0;">0dB</span>
                    <input type="range" min="-15" max="15" value="0" step="0.5" onchange="updateMasterEQ(11, this.value)" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100px; height: 6px;">
                    <span style="font-size: 10px; margin: 3px 0;">20kHz</span>
                </div>
            </div>
            <div style="text-align: center; margin-top: 10px;">
                <button onclick="resetMasterEQ()" style="background: #6c757d; color: white; padding: 8px 20px; border: none; border-radius: 8px; cursor: pointer;">Reset to Flat</button>
            </div>
        </div>

        <div class="timer" id="timer"></div>
        <div class="status idle" id="status">Ready to record</div>
        <div id="download-container" style="margin-top: 15px; text-align: center;"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.58/Tone.js"></script>
    <script>
        let audioCtx, masterDest, recorder, chunks;
        let timerInterval = null;
        let recordingStartTime = null;
        let masterSecondsElapsed = 0;
        const tracks = [];

        function switchView(trackId, mode) {
            const modes = ['monitor', 'playlist', 'eq'];
            modes.forEach(m => {
                const view = document.getElementById(`view-${m}${trackId}`);
                const btn = document.getElementById(`btn-tab-${m}${trackId}`);
                if (view) {
                    view.style.display = (m === mode) ? 'block' : 'none';
                }
                if (btn) {
                    if (m === mode) {
                        btn.style.background = "#667eea";
                        btn.style.color = "white";
                    } else {
                        btn.style.background = "#e9ecef";
                        btn.style.color = "#333";
                    }
                }
            });
        }

        function addToList(trackId) {
            const input = document.getElementById(`urlInput${trackId}`);
            const url = input.value.trim();
            if (!url) return;

            if (!tracks[trackId - 1]) {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    masterDest = audioCtx.createMediaStreamDestination();
                }
                tracks[trackId - 1] = new Track(audioCtx, masterDest, trackId);
            }

            const track = tracks[trackId - 1];
            track.playlist.push({ url: url, startTime: 0 });
            input.value = '';

            renderPlaylistUI(trackId);
        }

        function renderPlaylistUI(trackId) {
            const track = tracks[trackId - 1];
            if (!track) return;

            const ul = document.getElementById(`playlist${trackId}`);
            ul.innerHTML = track.playlist.map((item, index) => {
                const isPlaying = index === track.currentIndex;
                const className = isPlaying ? 'playing-stripe' : '';
                const inlineBg = isPlaying ? "" : "background: transparent;";
                return `
                <li class="${className}" style="display: flex; align-items: center; gap: 5px; padding: 10px; border-bottom: 1px solid #ddd;${inlineBg}">
                    <span style="flex: 1; font-size: 12px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; cursor: pointer;" onclick="loadFromPlaylist(${trackId}, ${index})">
                        ${index + 1}. ${item.url}
                    </span>
                    <div style="display: flex; gap: 2px;">
                        <button onclick="loadFromPlaylist(${trackId}, ${index})" style="background: #28a745; color: white; padding: 5px 8px; font-size: 10px;">üìºLoad</button>
                        <button onclick="moveItem(${trackId}, ${index}, -1)" style="padding: 5px 8px; font-size: 10px;">‚ñ≤</button>
                        <button onclick="moveItem(${trackId}, ${index}, 1)" style="padding: 5px 8px; font-size: 10px;">‚ñº</button>
                        <button onclick="removeFromList(${trackId}, ${index})" style="background: #dc3545; color: white; padding: 5px 8px; font-size: 10px;">√ó</button>
                    </div>
                </li>`;
            }).join('');
        }

        async function loadFromPlaylist(trackId, index, autoPlay = false) {
            const track = tracks[trackId - 1];
            if (!track) return;

            if (index >= track.playlist.length) {
                console.log("Playlist ended.");
                return;
            }

            const item = track.playlist[index];
            track.currentIndex = index;

            const mainUrlInput = document.getElementById(`url${trackId}`);
            if (mainUrlInput) mainUrlInput.value = item.url;

            try {
                await track.load();
                renderPlaylistUI(trackId);

                if (autoPlay) {
                    await track.video.play();
                } else {
                    switchView(trackId, 'monitor');
                }
            } catch (e) {
                console.warn(`Load failed for index ${index}: ${item.url}. Skipping to next...`);

                if (index < track.playlist.length - 1) {
                    setTimeout(() => {
                        loadFromPlaylist(trackId, index + 1, autoPlay);
                    }, 1000);
                } else {
                    setStatus(`Track ${trackId}: All items failed or ended`, 'error');
                }
            }
        }

        function moveItem(trackId, index, direction) {
            const track = tracks[trackId - 1];
            if (!track) return;

            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= track.playlist.length) return;

            const element = track.playlist.splice(index, 1)[0];
            track.playlist.splice(newIndex, 0, element);

            if (track.currentIndex === index) {
                track.currentIndex = newIndex;
            }

            renderPlaylistUI(trackId);
        }

        function removeFromList(trackId, index) {
            const track = tracks[trackId - 1];
            if (!track) return;

            track.playlist.splice(index, 1);

            if (track.currentIndex >= track.playlist.length) {
                track.currentIndex = Math.max(0, track.playlist.length - 1);
            }

            renderPlaylistUI(trackId);
        }

        function toggleMute(id) {
            if (tracks[id - 1]) tracks[id - 1].toggleMute();
        }

        function toggleTrackPlay(id) {
            const target = tracks[id - 1];
            if (target) {
                target.togglePlay();
            } else {
                alert(`Track ${id} „ÇíÂÖà„Å´ Set & Load „Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`);
            }
        }
        async function resetTrack(id) {
            const track = tracks[id - 1];
            if (!track) return;

            // ÁèæÂú®„ÅÆ„Ç™„Éï„Çª„ÉÉ„ÉàÂÄ§„ÇíÂèñÂæóÔºà„ÇØ„É™„Ç¢„Åó„Å™„ÅÑÔºÅÔºâ
            const offsetValue = parseFloat(document.getElementById(`start${id}`).value) || 0;
            console.log(`[Track ${id}] Resetting with offset: ${offsetValue}`);

            // Âº∑Âà∂„É™„Çª„ÉÉ„ÉàÔºà‰∏ÄÂ∫¶Êé•Á∂ö„ÇíÂÆåÂÖ®„Å´Âàá„ÇãÔºâ
            track.forceReset();

            // ÁèæÂú®„ÅÆÂÖ•ÂäõÊ¨ÑÔºàURL„Å®OffsetÔºâ„Å´Âü∫„Å•„ÅÑ„Å¶ÂÜç„É≠„Éº„Éâ
            // „Åì„Çå„Å´„Çà„Çä„ÄÅ„Çø„Ç§„É†Ë°®Á§∫„ÇÇ00:00:06„Å™„Å©„Åã„ÇâÂßã„Åæ„Çä„Åæ„Åô
            await track.load();
            // play() „ÇíÂëº„Å∞„Åö„ÄÅ„Éù„Éº„Ç∫Áä∂ÊÖã„Å´„Åô„Çã
            if (track.video) {
                track.video.pause();
                track.stopTimer(); // „Çø„Ç§„Éû„Éº„ÇÇÁ¢∫ÂÆü„Å´Ê≠¢„ÇÅ„Çã
            }
        }
        // function resetTrack(id) {
        //     const target = tracks[id - 1];
        //     if (target) {
        //         target.stopAndReset();
        //     }
        // }

        function updateRepeatMode(trackId) {
            updateRepeatStatus(trackId);
        }

        function updateRepeatStatus(trackId) {
            const track = tracks[trackId - 1];
            if (!track) return;

            const repeatMode = track.getRepeatMode();
            const statusElement = document.getElementById(`repeatStatus${trackId}`);

            if (!statusElement) return;

            switch(repeatMode) {
                case 'item':
                    statusElement.textContent = 'üîÇ Item Repeat';
                    statusElement.style.color = '#0066cc';
                    break;
                case 'list':
                    statusElement.textContent = 'üîÅ List Repeat';
                    statusElement.style.color = '#28a745';
                    break;
                default:
                    statusElement.textContent = 'No Repeat';
                    statusElement.style.color = '#495057';
            }
        }

        function updateEQ(trackId, band, value) {
            const track = tracks[trackId - 1];
            if (!track || !track.filters) return;

            const val = parseFloat(value);
            const filter = track.filters[band];
            if (filter) {
                filter.gain.setTargetAtTime(val, audioCtx.currentTime, 0.01);
                const display = document.getElementById(`eq-${band}-val${trackId}`);
                if (display) display.textContent = (val > 0 ? '+' : '') + val + 'dB';
            }
        }

        function updateMasterEQ(index, value) {
            if (!masterEQFilters[index]) return;
            const val = parseFloat(value);
            masterEQFilters[index].gain.setTargetAtTime(val, audioCtx.currentTime, 0.01);
            const display = document.getElementById(`meq-${index}`);
            if (display) display.textContent = (val > 0 ? '+' : '') + val + 'dB';
        }

        function resetMasterEQ() {
            masterEQFilters.forEach((filter, i) => {
                filter.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
                const slider = document.querySelector(`#master-eq-panel .eq-band:nth-child(${i + 1}) input`);
                if (slider) slider.value = 0;
                updateMasterEQ(i, 0);
            });
        }

        function toggleMasterEQ() {
            const panel = document.getElementById('master-eq-panel');
            const btn = document.getElementById('btn-master-eq');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                btn.style.background = '#667eea';
            } else {
                panel.style.display = 'none';
                btn.style.background = '#6c757d';
            }
        }
        // „Éî„ÉÉ„ÉÅÂ§âÊõ¥ÔºàÂçäÈü≥Âçò‰Ωç: -12 ÔΩû 12Ôºâ
        function updatePitch(trackId, value) {
            const track = tracks[trackId - 1];
            if (!track || !track.pitchShift) return;

            const userPitch = parseFloat(value);
            const speed = track.video.playbackRate;

            if (track.isFxEnabled) {
                // „Çπ„Éî„Éº„Éâ„Å´„Çà„ÇãÈü≥Á®ãÂ§âÂåñÂàÜ„ÇíÂ∑Æ„ÅóÂºï„ÅèÔºà12 * log2(speed) „ÅØ„Çπ„Éî„Éº„Éâ„Å´„Çà„Çã‰∏äÊòáÂàÜÔºâ
                const pitchOffset = 12 * Math.log2(speed);
                track.pitchShift.pitch = userPitch - pitchOffset;
            } else {
                track.pitchShift.pitch = userPitch;
            }

            const display = document.getElementById(`pitch-val${trackId}`);
            if (display) display.textContent = (userPitch > 0 ? '+' : '') + userPitch;
        }

        // „Çπ„Éî„Éº„ÉâÂ§âÊõ¥Ôºà0.5 ÔΩû 2.0Ôºâ
        function updateSpeed(trackId, value) {
            const track = tracks[trackId - 1];
            if (!track) return;

            const speed = parseFloat(value);
            track.video.playbackRate = speed;

            // ‚òÖ Â∏∏„Å´ÁèæÂú®„ÅÆ„Éî„ÉÉ„ÉÅ„Çπ„É©„Ç§„ÉÄ„Éº„ÅÆÂÄ§„ÇíÂèñÂæó„Åó„Å¶ÂÜçË®àÁÆó
            const pitchSlider = document.getElementById(`pitch-slider${trackId}`);
            const userPitch = pitchSlider ? parseFloat(pitchSlider.value) : 0;

            if (track.isFxEnabled && track.pitchShift) {
                const pitchOffset = 12 * Math.log2(speed);
                track.pitchShift.pitch = userPitch - pitchOffset;
            }

            const display = document.getElementById(`speed-val${trackId}`);
            if (display) display.textContent = speed.toFixed(2) + 'x';
        }
        class Track {
            constructor(ctx, dest, trackNum) {
                this.ctx = ctx;
                this.dest = dest;
                this.id = trackNum;
                this.video = document.getElementById(`v${this.id}`);
                this.volInput = document.getElementById(`vol${this.id}`);
                this.timeDisplay = document.getElementById(`time${this.id}`);
                this.playlist = [];
                this.currentIndex = 0;
                this.lastPos = 0;
                this.source = null;
                this.gain = null;
                this.isMuted = false;
                this.timerId = null;
                this.secondsElapsed = 0;
                this.btnPlayPause = document.getElementById(`playPause${this.id}`);
                this.repeatMode = 'none';
            }

            getRepeatMode() {
                const radios = document.getElementsByName(`repeatMode${this.id}`);
                for (const radio of radios) {
                    if (radio.checked) {
                        return radio.value;
                    }
                }
                return 'none';
            }

            resetToLastPos() {
                this.video.pause();
                const offsetTime = parseFloat(document.getElementById(`start${this.id}`).value) || 0;
                this.video.currentTime = offsetTime;
                this.stopTimer();
                this.secondsElapsed = offsetTime; // secondsElapsed„ÇÇÊõ¥Êñ∞
                this.timeDisplay.innerText = this.formatTime(offsetTime);
                if (this.btnPlayPause) this.btnPlayPause.innerText = "Play";
            }

            async togglePlay() {
                if (!this.video.src) {
                    console.warn(`[Track ${this.id}] No source loaded`);
                    return;
                }

                try {
                    // ‚òÖ Tone.js „ÅÆ„Ç®„É≥„Ç∏„É≥„ÇíÂßãÂãï„ÄÇ‰∏ÄÂ∫¶Ëµ∑Âãï„Åô„Çå„Å∞OK„ÄÇ
                    if (Tone.context.state !== 'running') {
                        await Tone.start();
                        console.log(`[Track ${this.id}] Tone.js Started`);
                    }
                    if (this.ctx && this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }

                    if (this.video.paused) {
                        this.lastPos = this.video.currentTime;
                        await this.video.play();
                        if (this.btnPlayPause) this.btnPlayPause.innerText = "Pause";
                    } else {
                        this.video.pause();
                        if (this.btnPlayPause) this.btnPlayPause.innerText = "Play";
                    }
                } catch (e) {
                    console.error(`[Track ${this.id}] Play/Pause error:`, e);
                    this.stopAndReset();
                    alert(`Track ${this.id}: Failed to play. Try reloading the track.`);
                }
            }

            stopAndReset() {
                try {
                    this.video.pause();
                    const offsetTime = parseFloat(document.getElementById(`start${this.id}`).value) || 0;
                    this.video.currentTime = offsetTime;
                    this.stopTimer();
                    this.secondsElapsed = offsetTime; // secondsElapsed„ÇÇÊõ¥Êñ∞
                    this.timeDisplay.innerText = this.formatTime(offsetTime); // offsetTime„ÇíÁõ¥Êé•Ë°®Á§∫
                    if (this.btnPlayPause) this.btnPlayPause.innerText = "Play";
                } catch (e) {
                    console.error(`[Track ${this.id}] Stop/Reset error:`, e);
                    this.stopTimer();
                    this.timeDisplay.innerText = "00:00:00";
                    if (this.btnPlayPause) this.btnPlayPause.innerText = "Play";
                }
            }

            setupNodes() {
                if (!this.source) {
                    setupMasterChain();
                    this.video.preservesPitch = false; // „Éñ„É©„Ç¶„Ç∂ÂÅ¥„ÅÆË£úÊ≠£„Çí„Ç™„Éï„Å´„Åô„Çã
                    Tone.setContext(this.ctx);

                    this.source = this.ctx.createMediaElementSource(this.video);

                    this.filters = {};
                    this.filters.low = this.ctx.createBiquadFilter();
                    this.filters.low.type = 'lowshelf';
                    this.filters.low.frequency.value = 320;
                    this.filters.low.gain.value = 0;

                    this.filters.mid = this.ctx.createBiquadFilter();
                    this.filters.mid.type = 'peaking';
                    this.filters.mid.frequency.value = 1000;
                    this.filters.mid.Q.value = 1.0;
                    this.filters.mid.gain.value = 0;

                    this.filters.high = this.ctx.createBiquadFilter();
                    this.filters.high.type = 'highshelf';
                    this.filters.high.frequency.value = 3200;
                    this.filters.high.gain.value = 0;

                    this.pitchShift = new Tone.PitchShift({
                        pitch: 0,
                        windowSize: 0.1
                    });

                    this.gain = this.ctx.createGain();
                    this.gain.gain.value = this.volInput.value;

                    this.filters.high.disconnect();
                    this.source.connect(this.filters.low);
                    this.filters.low.connect(this.filters.mid);
                    this.filters.mid.connect(this.filters.high);
                    //this.filters.high.connect(this.gain);
                    // high -> pitchShift (Tone.js) -> gain
                    Tone.connect(this.filters.high, this.pitchShift);
                    Tone.connect(this.pitchShift, this.gain);
                    this.gain.connect(masterEQFilters[0]);

                    this.volInput.oninput = () => {
                        const val = parseFloat(this.volInput.value);
                        if (!this.isMuted) {
                            this.gain.gain.setTargetAtTime(val, this.ctx.currentTime, 0.01);
                        }
                        const display = document.getElementById(`vol${this.id}-value`);
                        if (display) {
                            display.textContent = Math.round(val * 100) + '%';
                        }
                    };
                }
            }

            async load() {
                // AudioContext„ÅåsuspendedÁä∂ÊÖã„ÅÆÂ†¥Âêà„ÅØÂÜçÈñã
                if (this.ctx && this.ctx.state === 'suspended') {
                    console.log(`[Track ${this.id}] Resuming suspended AudioContext`);
                    await this.ctx.resume();
                }

                this.setupNodes();
                // ‚òÖ „Ç®„Éï„Çß„ÇØ„Éà„ÅÆ„É™„Çª„ÉÉ„Éà
                this.video.playbackRate = 1.0;
                if (this.pitchShift) this.pitchShift.pitch = 0;

                // ‚òÖ UIË°®Á§∫„ÅÆ„É™„Çª„ÉÉ„ÉàÔºàHTMLË¶ÅÁ¥†„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅÆ„ÅøÔºâ
                const pVal = document.getElementById(`pitch-val${this.id}`);
                const sVal = document.getElementById(`speed-val${this.id}`);
                if (pVal) pVal.textContent = "0";
                if (sVal) sVal.textContent = "1.00x";

                const pSlider = document.querySelector(`input[oninput*="updatePitch(${this.id}"]`);
                const sSlider = document.querySelector(`input[oninput*="updateSpeed(${this.id}"]`);
                if (pSlider) pSlider.value = 0;
                if (sSlider) sSlider.value = 1.0;

                const url = document.getElementById(`url${this.id}`).value;
                //const startTime = document.getElementById(`start${this.id}`).value || 0;
                // ‚òÖ startTime„ÇíÊï∞ÂÄ§„Å®„Åó„Å¶ÂèñÂæó
                const startTime = parseFloat(document.getElementById(`start${this.id}`).value) || 0;
                if (!url) return;

                this.stopTimer();
                //this.secondsElapsed = 0;
                //this.timeDisplay.innerText = "00:00:00";
                // ‚òÖ „Åì„Åì„Çí‰øÆÊ≠£Ôºö0„Åß„ÅØ„Å™„ÅèÊåáÂÆö„Åó„ÅüOffsetÁßíÊï∞„Åã„ÇâÈñãÂßã„Åô„Çã
                this.secondsElapsed = startTime;
                // ‚òÖ Ë°®Á§∫„ÇÇÂç≥Â∫ß„Å´ 00:00:06 „Å™„Å©„Å´Êõ¥Êñ∞„Åô„Çã
                this.timeDisplay.innerText = this.formatTime(this.secondsElapsed);
                // „Åô„Åπ„Å¶„ÅÆ„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº„Çí„ÇØ„É™„Ç¢
                const events = ['play', 'pause', 'ended', 'error', 'loadeddata', 'loadstart',
                               'canplay', 'seeking', 'seeked', 'stalled', 'suspend', 'waiting'];
                events.forEach(event => this.video[`on${event}`] = null);
                // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„ÅÆ app.py „ÅÆ audioÈñ¢Êï∞„Å∏ start „Éë„É©„É°„Éº„Çø„ÇíÊ∏°„Åô
                const proxyUrl = `/audio?url=${encodeURIComponent(url)}&start=${startTime}&format=mp4&repeat=false`;
                // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„ÅÆ app.py „ÅÆ audioÈñ¢Êï∞„Å∏ start „Éë„É©„É°„Éº„Çø„ÇíÊ∏°„Åô
                this.video.preservesPitch = false;
                // Âè§„ÅÑsrc„Çí„ÇØ„É™„Ç¢
                this.video.src = '';
                this.video.load();

                // „Éñ„É©„Ç¶„Ç∂„ÅÆÂÜÖÈÉ®Âá¶ÁêÜ„ÇíÂæÖ„Å§
                await new Promise(resolve => setTimeout(resolve, 100));

                // Êñ∞„Åó„ÅÑsrc„ÇíË®≠ÂÆö
                this.video.src = proxyUrl;
                this.video.muted = false;

                // „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº„ÇíÂÜçË®≠ÂÆö
                this.video.onplay = () => this.startTimer();
                this.video.onpause = () => this.stopTimer();

                this.video.onended = () => {
                    this.stopTimer();

                    const repeatMode = this.getRepeatMode();

                    if (repeatMode === 'item') {
                        this.restart();
                    } else if (this.currentIndex < this.playlist.length - 1) {
                        this.currentIndex++;
                        loadFromPlaylist(this.id, this.currentIndex, true);
                    } else if (repeatMode === 'list') {
                        this.currentIndex = 0;
                        loadFromPlaylist(this.id, this.currentIndex, true);
                    } else {
                        this.stopAndReset();
                    }
                };

                return new Promise((resolve, reject) => {
                    let resolved = false;

                    this.video.onloadeddata = () => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            // ÂÖ•ÂäõÊ¨Ñ„ÅÆÈñãÂßãÁßíÊï∞„ÇíÂèñÂæó„Åó„Å¶„Ç∑„Éº„ÇØ
                            //const startTime = parseFloat(document.getElementById(`start${this.id}`).value) || 0;
                            //this.video.currentTime = startTime;
                            // ‚òÖ ÈáçË¶ÅÔºö„Çµ„Éº„Éê„ÉºÂÅ¥„Åß-ss„Åï„Çå„Å¶„ÅÑ„Å¶„ÇÇ„ÄÅ„Éñ„É©„Ç¶„Ç∂„ÅÆÂÜçÁîü„Éò„ÉÉ„Éâ„ÇíÊòéÁ§∫ÁöÑ„Å´Âêà„Çè„Åõ„Çã
                            this.video.currentTime = startTime;
                            // ÁßíÊï∞Ë°®Á§∫ [6s] „Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Åì„Åì„Åß„ÇÇÊõ¥Êñ∞
                            const secEl = document.getElementById(`seconds${this.id}`);
                            if (secEl) secEl.innerText = `[${Math.floor(this.secondsElapsed)}s]`;
                            console.log(`[Track ${this.id}] Loaded successfully`);
                            resolve();
                        }
                    };
                    this.video.oncanplay = () => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);

                            //const startTime = parseFloat(document.getElementById(`start${this.id}`).value) || 0;

                            try {
                                this.video.currentTime = startTime;
                            } catch (e) {
                                console.warn("Seek failed, but server should handle it.");
                            }

                            this.video.pause(); // „É≠„Éº„ÉâÁõ¥Âæå„ÅØ„Éù„Éº„Ç∫
                            resolve();
                        }
                    };
                    this.video.onerror = (e) => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            console.error(`[Track ${this.id}] Video error:`, e);

                            // „Ç®„É©„ÉºÊôÇ„ÅØÂº∑Âà∂„É™„Çª„ÉÉ„Éà
                            this.forceReset();

                            reject(new Error(`Video element error: ${this.video.error ? this.video.error.message : 'Unknown'}`));
                        }
                    };

                    const timeoutId = setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            console.error(`[Track ${this.id}] Load timeout`);

                            // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊôÇ„ÇÇÂº∑Âà∂„É™„Çª„ÉÉ„Éà
                            this.forceReset();

                            reject(new Error("Load timeout (15s)"));
                        }
                    }, 15000);

                    this.video.load();
                });
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                const btn = document.getElementById(`mute${this.id}`);
                if (this.isMuted) {
                    this.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.01);
                    btn.innerText = "Unmute";
                    btn.style.background = "#dc3545";
                } else {
                    this.gain.gain.setTargetAtTime(this.volInput.value, this.ctx.currentTime, 0.01);
                    btn.innerText = "Mute";
                    btn.style.background = "#6c757d";
                }
            }
            startTimer() {
                this.stopTimer();

                // load() „ÅßË®≠ÂÆö„Åï„Çå„Åü this.secondsElapsed (OffsetÂÄ§) „ÇíÂü∫ÁÇπ„Å´„Åô„Çã
                const currentSeconds = this.secondsElapsed;
                const startTimeAtClick = Date.now();

                this.timerId = setInterval(() => {
                    if (this.video && !this.video.paused) {
                        const now = Date.now();
                        const sessionSeconds = Math.floor((now - startTimeAtClick) / 1000);

                        // Âü∫ÁÇπ + ÁµåÈÅéÂàÜ
                        this.secondsElapsed = currentSeconds + sessionSeconds;
                        this.timeDisplay.innerText = this.formatTime(this.secondsElapsed);

                        // ÁßíÊï∞Ë°®Á§∫ [6s] „ÅÆÊõ¥Êñ∞
                        const secEl = document.getElementById(`seconds${this.id}`);
                        if (secEl) secEl.innerText = `[${this.secondsElapsed}s]`;
                    }
                }, 200);
            }

            // startTimer() {
            //     this.stopTimer();

            //     const timeStr = this.timeDisplay.innerText.trim();
            //     const parts = timeStr.split(':').map(Number);
            //     let currentSeconds = 0;

            //     if (parts.length === 3) {
            //         currentSeconds = (parts[0] * 3600) + (parts[1] * 60) + parts[2];
            //     } else if (parts.length === 2) {
            //         currentSeconds = (parts[0] * 60) + parts[1];
            //     }

            //     const startTimeAtClick = Date.now();
            //     this.secondsElapsed = currentSeconds;

            //     this.timerId = setInterval(() => {
            //         if (this.video && !this.video.paused) {
            //             const now = Date.now();
            //             const sessionSeconds = Math.floor((now - startTimeAtClick) / 1000);
            //             this.secondsElapsed = currentSeconds + sessionSeconds;
            //             this.timeDisplay.innerText = this.formatTime(this.secondsElapsed);
            //             // ‚òÖ „Åì„Åì„Å´ËøΩÂä†ÔºöÁßíÊï∞„ÅÆ„Åø„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
            //             const secEl = document.getElementById(`seconds${this.id}`);
            //             if (secEl) secEl.innerText = `[${this.secondsElapsed}s]`;
            //         }
            //     }, 200);
            // }

            stopTimer() {
                if (this.timerId) {
                    clearInterval(this.timerId);
                    this.timerId = null;
                }
            }

            formatTime(seconds) {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = Math.floor(seconds % 60);
                if (h > 0) {
                    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                }
                return `00:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }

            async restart() {
                try {
                    this.video.currentTime = 0;
                    this.secondsElapsed = 0;
                    this.timeDisplay.innerText = "00:00:00";
                    await this.video.play();
                } catch (e) {
                    console.error(`[Track ${this.id}] Restart failed:`, e);
                    const currentUrl = document.getElementById(`url${this.id}`).value;
                    if (currentUrl) {
                        console.log(`[Track ${this.id}] Attempting to reload...`);
                        try {
                            await this.load();
                            await this.video.play();
                        } catch (reloadError) {
                            console.error(`[Track ${this.id}] Reload also failed:`, reloadError);
                            alert(`Track ${this.id}: Cannot restart. Please reload manually.`);
                        }
                    }
                }
            }

            // Âº∑Âà∂„É™„Çª„ÉÉ„ÉàÔºàËªΩÈáèÁâàÔºâ- „Ç®„É©„ÉºÊôÇ„Å´Ëá™ÂãïÂÆüË°å
            forceReset() {
                console.log(`[Track ${this.id}] Force reset initiated`);
                try {
                    const events = ['play', 'pause', 'ended', 'error', 'loadeddata', 'loadstart',
                                   'canplay', 'seeking', 'seeked', 'stalled', 'suspend', 'waiting',
                                   'abort', 'emptied'];
                    events.forEach(event => { this.video[`on${event}`] = null; });

                    this.video.pause();
                    this.video.removeAttribute('src');
                    this.video.load();

                    this.stopTimer();
                    this.secondsElapsed = 0;
                    this.timeDisplay.innerText = "00:00:00";
                    if (this.btnPlayPause) this.btnPlayPause.innerText = "Play";
                    console.log(`[Track ${this.id}] Force reset completed`);
                } catch (e) {
                    console.error(`[Track ${this.id}] Force reset error:`, e);
                }
            }

            // „Éè„Éº„Éâ„É™„Çª„ÉÉ„ÉàÔºàÂÆåÂÖ®ÂÜçÊßãÁØâÔºâ- üîß„Éú„Çø„É≥„ÅßÊâãÂãïÂÆüË°å
            async hardReset() {
                console.log(`[Track ${this.id}] Hard reset: destroying and recreating video element`);

                // „Ç™„Éº„Éá„Ç£„Ç™„Éé„Éº„Éâ„ÅÆÂÆåÂÖ®„Å´ÂàáÊñ≠
                try {
                    if (this.source) { this.source.disconnect(); this.source = null; }
                    if (this.filters) {
                        Object.values(this.filters).forEach(f => { try { f.disconnect(); } catch(e){} });
                    }
                    if (this.gain) { try { this.gain.disconnect(); } catch(e){} this.gain = null; }
                } catch (e) {
                    console.error(`[Track ${this.id}] Error disconnecting audio nodes:`, e);
                }

                // Âè§„ÅÑvideoË¶ÅÁ¥†„ÇíÂâäÈô§„Åó„Å¶Êñ∞Ë¶è‰ΩúÊàê
                const oldVideo = this.video;
                const parent = oldVideo.parentElement;
                if (!parent) {
                    console.error(`[Track ${this.id}] Parent element not found!`);
                    return;
                }

                const newVideo = document.createElement('video');
                newVideo.id = `v${this.id}`;
                newVideo.setAttribute('width', '100%');
                newVideo.setAttribute('height', 'auto');
                newVideo.style.cssText = 'border-radius: 8px; background: #000; margin-bottom: 12px; display: block;';
                newVideo.setAttribute('crossorigin', 'anonymous');
                newVideo.setAttribute('playsinline', '');
                newVideo.muted = false;

                parent.replaceChild(newVideo, oldVideo);
                this.video = newVideo;

                // „Ç™„Éº„Éá„Ç£„Ç™„Éé„Éº„Éâ„ÇíÂÜçÊßãÁØâ
                this.source = null;
                this.filters = null;
                this.gain = null;

                await new Promise(resolve => setTimeout(resolve, 200));
                this.setupNodes();

                // UIÁä∂ÊÖã„É™„Çª„ÉÉ„Éà
                this.stopTimer();
                this.secondsElapsed = 0;
                this.timeDisplay.innerText = "00:00:00";
                if (this.btnPlayPause) this.btnPlayPause.innerText = "Play";

                console.log(`[Track ${this.id}] Hard reset completed - ready to load new content`);
                alert(`Track ${this.id} has been hard reset successfully.\nYou can now load content again.`);
            }

            stop() {
                this.video.pause();
                this.stopTimer();
            }
        }

        const btnStart = document.getElementById('btn-start');
        const btnStop = document.getElementById('btn-stop');
        const btnCancel = document.getElementById('btn-cancel');
        const status = document.getElementById('status');
        const btnPause = document.getElementById('btn-pause');
        const btnRecPause = document.getElementById('btn-rec-pause');

        let masterGain = null;
        let masterEQFilters = [];
        const masterEQFreqs = [20, 60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000, 16000, 20000];

        function setupMasterChain() {
            if (masterGain || !audioCtx) return;

            masterEQFilters = masterEQFreqs.map(freq => {
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'peaking';
                filter.frequency.value = freq;
                filter.Q.value = 1.0;
                filter.gain.value = 0;
                return filter;
            });

            masterGain = audioCtx.createGain();
            masterGain.gain.value = 1.0;

            for (let i = 0; i < masterEQFilters.length - 1; i++) {
                masterEQFilters[i].connect(masterEQFilters[i + 1]);
            }

            const lastEQ = masterEQFilters[masterEQFilters.length - 1];
            lastEQ.connect(masterGain);
            masterGain.connect(audioCtx.destination);
            masterGain.connect(masterDest);

            const mVol = document.getElementById('masterVol');
            const mVolVal = document.getElementById('masterVol-value');

            const initialVal = parseFloat(mVol.value);
            masterGain.gain.setValueAtTime(initialVal, audioCtx.currentTime);
            if (mVolVal) mVolVal.textContent = Math.round(initialVal * 100) + '%';

            mVol.oninput = () => {
                const val = parseFloat(mVol.value);
                masterGain.gain.setTargetAtTime(val, audioCtx.currentTime, 0.01);
                if (mVolVal) {
                    mVolVal.textContent = Math.round(val * 100) + '%';
                }
            };
        }

        let isPlayingAll = false;

        async function playAllTracks() {
            const btnPlayAll = document.querySelector('button[onclick="playAllTracks()"]');

            if (!isPlayingAll) {
                if (tracks.length === 0 || tracks.every(t => !t || !t.video.src)) {
                    return setStatus("No tracks loaded", "error");
                }

                // AudioContext„ÅåsuspendedÁä∂ÊÖã„ÅÆÂ†¥Âêà„ÅØÂÜçÈñã
                if (audioCtx && audioCtx.state === 'suspended') {
                    await audioCtx.resume();
                }

                isPlayingAll = true;
                btnPlayAll.innerText = "‚ñ† All Stop";
                btnPlayAll.style.background = "#dc3545";

                tracks.forEach(t => {
                    if (t && t.video) {
                        t.lastPos = t.video.currentTime;
                    }
                });

                tracks.forEach(t => {
                    if (t && t.video.src) {
                        t.video.play();
                        t.startTimer();
                        if (t.btnPlayPause) t.btnPlayPause.innerText = "Pause";
                    }
                });
                startMasterTimer();

                btnStart.disabled = true;
                btnPause.disabled = false;
                setStatus("Monitoring: All tracks playing", "success");

            } else {
                stopEverything();
                tracks.forEach(t => {
                    if (t) t.resetToLastPos();
                });
            }
        }

        function stopEverything() {
            isPlayingAll = false;

            const btnPlayAll = document.querySelector('button[onclick="playAllTracks()"]');
            if (btnPlayAll) {
                btnPlayAll.innerText = "‚ñ∂ Play All Tracks";
                btnPlayAll.style.background = "#007bff";
            }

            tracks.forEach(t => {
                if (t) {
                    t.video.pause();
                    t.stopAndReset();
                    const startTime = parseFloat(document.getElementById(`start${t.id}`).value) || 0;
                    t.video.currentTime = startTime;
                    t.stopTimer();
                    t.secondsElapsed = 0;

                    const timeDisplay = document.getElementById(`time${t.id}`);
                    if (timeDisplay) timeDisplay.textContent = "00:00:00";
                }
            });

            if (timerInterval) clearInterval(timerInterval);
            masterSecondsElapsed = 0;

            const timerElement = document.getElementById('timer');
            if (timerElement) {
                timerElement.innerHTML = `<span style="font-size: 14px; color: #999; vertical-align: middle;">REC</span> 00:00:00`;
            }

            if (recorder && recorder.state !== 'inactive') {
                recorder.stop();
            } else {
                setStatus("Stopped & Reset", "idle");
                btnStart.disabled = false;
                btnPause.disabled = true;
                btnPause.innerText = "Pause";
                btnPause.style.background = "#ffc107";
                btnPause.style.color = "#000";
            }
        }

        function setStatus(text, type = 'idle') {
            status.className = `status ${type}`;
            if (type === 'loading') {
                status.innerHTML = `<span class="spinner"></span>${text}`;
            } else {
                status.textContent = text;
            }
        }

        function startMasterTimer(forceReset = false) {
            if (timerInterval) clearInterval(timerInterval);

            const timerElement = document.getElementById('timer');
            let elapsedMs = 0;

            if (!forceReset) {
                const currentText = timerElement.textContent || "00:00:00";
                const timeMatch = currentText.match(/(\d+:)?(\d+):(\d+)/);

                if (timeMatch) {
                    const parts = timeMatch[0].split(':').map(Number);
                    if (parts.length === 3) {
                        elapsedMs = (parts[0] * 3600 + parts[1] * 60 + parts[2]) * 1000;
                    } else if (parts.length === 2) {
                        elapsedMs = (parts[0] * 60 + parts[1]) * 1000;
                    }
                }
            }

            recordingStartTime = Date.now() - elapsedMs;

            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const h = Math.floor(elapsed / 3600).toString().padStart(2, '0');
                const m = Math.floor((elapsed % 3600) / 60).toString().padStart(2, '0');
                const s = Math.floor(elapsed % 60).toString().padStart(2, '0');

                timerElement.innerHTML = `<span style="font-size: 14px; color: #999; vertical-align: middle;">REC</span> ${h}:${m}:${s}`;
            }, 200);
        }

        function cleanup() {
            tracks.forEach(t => {
                if (t && t.destroy) t.destroy();
            });
            tracks.length = 0;

            if (recorder && recorder.state !== 'inactive') {
                recorder.stop();
            }
            recorder = null;
            chunks = [];

            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            document.getElementById('timer').textContent = '';
        }

        btnStart.onclick = async () => {
            try {
                const timerElement = document.getElementById('timer');
                timerElement.classList.add('recording-bg');
                btnStop.classList.add('recording-active');

                if (tracks.length === 0 || tracks.every(t => !t || !t.video.src)) {
                    throw new Error('Please Load at least one track first');
                }

                setStatus('Starting Recording...', 'loading');

                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    masterDest = audioCtx.createMediaStreamDestination();
                }
                await audioCtx.resume();

                chunks = [];
                recorder = new MediaRecorder(masterDest.stream, { mimeType: 'audio/webm;codecs=opus' });
                recorder.ondataavailable = e => {
                    if (e.data.size > 0) chunks.push(e.data);
                };
                recorder.onstop = saveFile;

                tracks.forEach(t => {
                    if (t && t.video) {
                        t.lastPos = t.video.currentTime;
                    }
                });

                recorder.start();
                startMasterTimer(true);
                btnPause.disabled = false;
                btnRecPause.disabled = false;

                tracks.forEach(t => {
                    if (t && t.video.src) {
                        t.video.play();
                        if (t.btnPlayPause) t.btnPlayPause.innerText = "Pause";
                    }
                });

                setStatus('Recording...', 'recording');
                btnStart.disabled = true;
                btnStop.disabled = false;
                btnCancel.disabled = false;

            } catch (error) {
                console.error('Start error:', error);
                setStatus(error.message, 'error');
            }
        };

        btnStop.onclick = () => {
            try {
                const timerElement = document.getElementById('timer');
                timerElement.classList.remove('recording-bg');
                btnStop.classList.remove('recording-active');

                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }

                if (recorder && recorder.state === 'recording') {
                    recorder.stop();
                }

                tracks.forEach(t => {
                    if (t) {
                        t.stop();
                        t.stopAndReset();
                    }
                });

                setStatus('Processing...', 'loading');
                btnStop.disabled = true;
                btnCancel.disabled = true;
            } catch (error) {
                console.error('Stop error:', error);
                setStatus('Failed to stop recording', 'error');
                cleanup();
                btnStart.disabled = false;
            }
        };

        btnCancel.onclick = () => {
            try {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }

                recordingStartTime = null;

                const btnPlayAll = document.querySelector('button[onclick="playAllTracks()"]');
                if (btnPlayAll) {
                    btnPlayAll.innerText = "‚ñ∂ Play All Tracks";
                    btnPlayAll.style.background = "#007bff";
                }
                isPlayingAll = false;

                const timerElement = document.getElementById('timer');
                timerElement.innerHTML = `<span style="font-size: 14px; color: #999; vertical-align: middle;">REC</span> 00:00:00`;
                timerElement.classList.remove('recording-bg');
                btnStop.classList.remove('recording-active');

                if (recorder) {
                    recorder.onstop = null;
                    if (recorder.state !== 'inactive') {
                        recorder.stop();
                    }
                }

                tracks.forEach(t => {
                    if (t) {
                        t.stop();
                        t.stopAndReset();
                        t.resetToLastPos();
                    }
                });

                cleanup();

                setStatus('Recording canceled.', 'idle');
                btnStart.disabled = false;
                btnStop.disabled = true;
                btnCancel.disabled = true;
                btnPause.disabled = true;
                btnRecPause.disabled = true;
                btnRecPause.innerText = "REC Pause";
                btnPause.innerText = "Pause";

            } catch (error) {
                console.error('Cancel error:', error);
                setStatus('Failed to cancel recording', 'error');
                btnStart.disabled = false;
            }
        };

        btnRecPause.onclick = () => {
            if (!recorder || recorder.state === 'inactive') return;

            if (recorder.state === 'recording') {
                recorder.pause();
                clearInterval(timerInterval);
                btnRecPause.innerText = "Resume REC";
                btnRecPause.style.background = "#28a745";
                setStatus("REC paused (video playing...)", "loading");
            } else if (recorder.state === 'paused') {
                recorder.resume();
                startMasterTimer();
                btnRecPause.innerText = "REC Pause";
                btnRecPause.style.background = "#fd7e14";
                setStatus("Recording...", "success");
            }
        };

        btnPause.onclick = () => {
            const isRecording = recorder && (recorder.state === 'recording' || recorder.state === 'paused');

            if (isRecording || isPlayingAll) {
                const isCurrentlyMoving = tracks.some(t => t && t.video && !t.video.paused);

                if (isCurrentlyMoving) {
                    tracks.forEach(t => {
                        if (t && t.video) {
                            t.video.pause();
                            if (t.btnPlayPause) t.btnPlayPause.innerText = "Play";
                            t.stopTimer();
                        }
                    });

                    if (isRecording && recorder.state === 'recording') recorder.pause();

                    clearInterval(timerInterval);
                    timerInterval = null;
                    btnPause.innerText = "Resume";
                    setStatus("Paused", "loading");
                } else {
                    tracks.forEach(t => {
                        if (t && t.video) {
                            t.video.play().catch(e => console.warn("Playback prevented", e));
                            t.startTimer();
                            if (t.btnPlayPause) t.btnPlayPause.innerText = "Pause";
                        }
                    });

                    startMasterTimer(false);

                    btnPause.innerText = "Pause";
                    setStatus(isRecording ? "Recording..." : "Playing...", "success");
                }
            }
        };

        async function saveFile() {
            if (chunks.length === 0) {
                setStatus("No recording data", "error");
                return;
            }

            const blob = new Blob(chunks, { type: 'audio/webm' });
            const timestamp = Date.now();

            const shouldDownloadWebm = document.getElementById('downloadWebM')?.checked;
            if (shouldDownloadWebm) {
                const webmUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = webmUrl;
                a.download = `check_raw_${timestamp}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(webmUrl), 1000);
            }

            setStatus("Uploading for MP3 conversion...", "loading");

            try {
                const formData = new FormData();
                formData.append('file', blob, `recording_${timestamp}.webm`);

                const response = await fetch('/convert/start', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server upload failed: ${errorText}`);
                }

                const { job_id } = await response.json();
                console.log("Conversion Job ID:", job_id);

                const pollInterval = setInterval(async () => {
                    try {
                        const statusRes = await fetch(`/convert/status/${job_id}`);
                        if (!statusRes.ok) return;

                        const data = await statusRes.json();

                        if (data.status === 'completed') {
                            clearInterval(pollInterval);
                            setStatus("MP3 Conversion Complete!", "success");

                            const container = document.getElementById('download-container');
                            const timestamp = new Date().toLocaleString();

                            container.innerHTML = `
                                <div style="padding: 15px; background: #fff; border: 2px solid #28a745; border-radius: 8px;">
                                    <p style="margin-bottom: 10px; font-weight: bold; color: #333;">Mixed MP3</p>
                                    <a href="${data.url}"
                                    download="mixed_recording_${Date.now()}.mp3"
                                    style="display: inline-block; padding: 10px 20px; background: #28a745; color: white; text-decoration: none; border-radius: 5px; font-weight: bold;">
                                    Click to Download MP3
                                    </a>
                                    <p style="font-size: 10px; color: #666; margin-top: 8px;">Generated at: ${timestamp}</p>
                                </div>
                            `;

                            btnStart.disabled = false;

                        } else if (data.status === 'failed') {
                            clearInterval(pollInterval);
                            const msg = data.reason === 'timeout' ? "Timeout (Process too long)" : "Conversion failed";
                            setStatus(msg, "error");
                            btnStart.disabled = false;
                        } else {
                            setStatus(`Converting... (Job: ${job_id})`, "loading");
                        }
                    } catch (pollErr) {
                        console.error("Polling error:", pollErr);
                    }
                }, 2000);

            } catch (error) {
                console.error("Save error:", error);
                setStatus(`Error: ${error.message}`, "error");
                btnStart.disabled = false;
            }
        }

        window.addEventListener('beforeunload', (e) => {
            if (recorder && recorder.state === 'recording') {
                e.preventDefault();
                e.returnValue = '';
                return 'Recording in progress. Are you sure you want to leave?';
            }
        });

        // === Track Hard Reset ===
        function hardResetTrack(trackId) {
            const track = tracks[trackId - 1];
            if (track) {
                track.hardReset();
            } else {
                console.error(`Track ${trackId} not found or not initialized`);
                alert(`Track ${trackId} is not initialized yet.\nPlease add a URL to the playlist first.`);
            }
        }

        // === LiveStream Functions ===
        let livestreamWS = null;
        let livestreamRecorder = null;
        let livestreamActive = false;
        let retryCount = 0;
        const MAX_RETRY = 5;

        function resetFFmpegDefaults() {
            document.getElementById('videoBitrate').value = 750;
            document.getElementById('videoBitrateValue').textContent = '750k';
            document.getElementById('audioBitrate').value = 128;
            document.getElementById('audioBitrateValue').textContent = '128k';
            document.getElementById('gopSize').value = 60;
            document.getElementById('gopSizeValue').textContent = '60';
            document.getElementById('bufferSize').value = 4096;
            document.getElementById('bufferSizeValue').textContent = '4096';
            document.getElementById('asyncParam').value = 0;
            document.getElementById('asyncValue').textContent = '0';
            document.getElementById('chunkInterval').value = 50;
            document.getElementById('chunkIntervalValue').textContent = '50';
            document.getElementById('denoiseEnabled').checked = true;
        }

        async function startLiveStream() {
            const rtmpUrl = document.getElementById('rtmpUrl').value.trim();
            if (!rtmpUrl) {
                alert('Please enter RTMP URL');
                return;
            }

            if (!rtmpUrl.startsWith('rtmp://') && !rtmpUrl.startsWith('rtmps://')) {
                alert('Invalid RTMP URL. Must start with rtmp:// or rtmps://');
                return;
            }

            const videoSource = document.querySelector('input[name="videoSource"]:checked').value;

            if (!audioCtx || !masterDest) {
                alert('Please load at least one track before starting livestream');
                return;
            }

            try {
                const ffmpegParams = {
                    video_bitrate: parseInt(document.getElementById('videoBitrate').value),
                    audio_bitrate: parseInt(document.getElementById('audioBitrate').value),
                    gop_size: parseInt(document.getElementById('gopSize').value),
                    buffer_size: parseInt(document.getElementById('bufferSize').value),
                    async_param: parseInt(document.getElementById('asyncParam').value),
                    chunk_interval: parseInt(document.getElementById('chunkInterval').value),
                    denoise_enabled: document.getElementById('denoiseEnabled').checked
                };

                console.log('[LiveStream] FFmpeg params:', ffmpegParams);

                const response = await fetch('/livestream/start', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        rtmp_url: rtmpUrl,
                        video_track: parseInt(videoSource),
                        ffmpeg_params: ffmpegParams
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to start livestream');
                }

                livestreamActive = true;
                retryCount = 0;

                setupWebSocket(videoSource, ffmpegParams);

            } catch (error) {
                console.error('[LiveStream] Start error:', error);
                alert('Failed to start livestream: ' + error.message);
            }
        }

        function setupWebSocket(videoSource, ffmpegParams) {
            if (!livestreamActive) return;

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/livestream/ws`;
            console.log(`[LiveStream] Connecting to: ${wsUrl} (attempt ${retryCount + 1})`);

            livestreamWS = new WebSocket(wsUrl);

            livestreamWS.onopen = async () => {
                console.log('[LiveStream] WebSocket connected - Hybrid Mode');
                retryCount = 0;

                const selectedTrack = tracks[parseInt(videoSource) - 1];

                if (!selectedTrack || selectedTrack.playlist.length === 0) {
                    alert('Selected track has no playlist items');
                    stopLiveStream();
                    return;
                }
                // === ËøΩÂä†Ôºö„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ‰∏çÊ≠£„Å™„Ç∫„É¨„Çí„Åì„Åì„ÅßÁõ¥„Åô ===
                let safeIndex = selectedTrack.currentIndex;
                if (safeIndex >= selectedTrack.playlist.length) {
                    console.log(`[LiveStream] Index ${safeIndex} out of bounds, resetting to 0`);
                    safeIndex = 0;
                    selectedTrack.currentIndex = 0; // „Éà„É©„ÉÉ„ÇØÂÅ¥„ÅÆÁä∂ÊÖã„ÇÇÊàª„Åó„Å¶„Åä„Åè
                } else {
                    console.log(`[LiveStream] Index ${safeIndex} is safe`);
                }

                const playlistData = {
                    playlist: selectedTrack.playlist.map(item => item.url),
                    current_index: safeIndex,
                    //current_index: selectedTrack.currentIndex,
                    repeat_mode: selectedTrack.getRepeatMode()
                };

                console.log('[LiveStream] Sending playlist:', playlistData);
                livestreamWS.send(JSON.stringify(playlistData));

                const audioStream = masterDest.stream;

                try {
                    livestreamRecorder = new MediaRecorder(audioStream, {
                        mimeType: 'audio/webm;codecs=opus',
                        audioBitsPerSecond: 128000
                    });

                    let chunkCount = 0;
                    livestreamRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0 && livestreamWS && livestreamWS.readyState === WebSocket.OPEN) {
                            chunkCount++;
                            if (chunkCount % 50 == 0) {
                                console.log(`[LiveStream] Sent ${chunkCount} audio chunks`);
                            }
                            livestreamWS.send(event.data);
                        }
                    };

                    livestreamRecorder.start(ffmpegParams.chunk_interval);

                    document.getElementById('btn-livestream-start').disabled = true;
                    document.getElementById('btn-livestream-stop').disabled = false;
                    document.getElementById('btn-livestream-stop').style.background = '#e74c3c';
                    document.getElementById('livestream-status').textContent = 'üî¥ LIVE (Hybrid Mode)';
                    document.getElementById('livestream-status').style.background = '#ffebee';
                    document.getElementById('livestream-status').style.color = '#c62828';

                } catch (e) {
                    console.error('[LiveStream] MediaRecorder creation failed:', e);
                    alert('Failed to create audio recorder: ' + e.message);
                    stopLiveStream();
                }
            };

            livestreamWS.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    console.log('[LiveStream] Message from server:', msg);

                    if (msg.type === 'progress') {
                        // currentIndex„Çí„Éà„É©„ÉÉ„ÇØ„Å´ÂêåÊúü
                        const selectedTrack = tracks[parseInt(videoSource) - 1];
                        if (selectedTrack) {
                            selectedTrack.currentIndex = msg.current_index;
                        }
                        const statusEl = document.getElementById('livestream-status');
                        statusEl.textContent = `üî¥ LIVE - Item ${msg.current_index + 1}/${msg.total}`;
                    } else if (msg.type === 'completed') {
                        console.log('[LiveStream] Playlist completed');
                        stopLiveStream();
                    } else if (msg.error) {
                        console.error('[LiveStream] Server error:', msg.error);
                        alert('LiveStream error: ' + msg.error);
                        stopLiveStream();
                    }
                } catch (e) {
                    console.log('[LiveStream] Non-JSON message:', event.data);
                }
            };

            livestreamWS.onclose = (event) => {
                console.warn(`[LiveStream] WebSocket closed: code=${event.code}, reason=${event.reason}`);

                if (event.code !== 1000 && livestreamActive && retryCount < MAX_RETRY) {
                    const delay = Math.min(1000 * Math.pow(2, retryCount), 10000);
                    console.log(`[Retry] Attempt ${retryCount + 1}/${MAX_RETRY} in ${delay}ms...`);

                    const statusEl = document.getElementById('livestream-status');
                    statusEl.textContent = `‚ö†Ô∏è Reconnecting... (${retryCount + 1}/${MAX_RETRY})`;
                    statusEl.style.background = '#fff3cd';
                    statusEl.style.color = '#856404';

                    setTimeout(() => {
                        retryCount++;
                        setupWebSocket(videoSource, ffmpegParams);
                    }, delay);

                } else if (event.code === 1000 || !livestreamActive) {
                    console.log('[LiveStream] Normal closure');
                } else {
                    console.error('[LiveStream] Max retry attempts reached');
                    stopLiveStream();
                    alert('Connection failed after multiple retries.');
                }
            };

            livestreamWS.onerror = (error) => {
                console.error('[LiveStream] WebSocket error:', error);
            };
        }

        async function stopLiveStream() {
            console.log('[LiveStream] Stopping...');
            livestreamActive = false;
            retryCount = 0;

            if (livestreamRecorder && livestreamRecorder.state !== 'inactive') {
                livestreamRecorder.stop();
            }

            if (livestreamWS) {
                livestreamWS.close(1000);
                livestreamWS = null;
            }

            try {
                await fetch('/livestream/stop', { method: 'POST' });
            } catch (error) {
                console.error('[LiveStream] Stop error:', error);
            }

            livestreamRecorder = null;

            document.getElementById('btn-livestream-start').disabled = false;
            document.getElementById('btn-livestream-stop').disabled = true;
            document.getElementById('btn-livestream-stop').style.background = '#95a5a6';
            document.getElementById('livestream-status').textContent = 'Idle';
            document.getElementById('livestream-status').style.background = '#ecf0f1';
            document.getElementById('livestream-status').style.color = '#7f8c8d';
        }
    </script>
</body>
</html>
